/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type MatcherObservation struct {
}

type MatcherParameters struct {

	// The name of the label to match against.
	// +kubebuilder:validation:Required
	Label *string `json:"label" tf:"label,omitempty"`

	// The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
	// +kubebuilder:validation:Required
	Match *string `json:"match" tf:"match,omitempty"`

	// The label value to match against.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type NotificationPolicyObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type NotificationPolicyParameters struct {

	// The default contact point to route all unmatched notifications to.
	// +crossplane:generate:reference:type=github.com/grafana/crossplane-provider-grafana/apis/alerting/v1alpha1.ContactPoint
	// +crossplane:generate:reference:extractor=github.com/grafana/crossplane-provider-grafana/config/grafana.NameExtractor()
	// +crossplane:generate:reference:refFieldName=ContactPointRef
	// +crossplane:generate:reference:selectorFieldName=ContactPointSelector
	// +kubebuilder:validation:Optional
	ContactPoint *string `json:"contactPoint,omitempty" tf:"contact_point,omitempty"`

	// Reference to a ContactPoint in alerting to populate contactPoint.
	// +kubebuilder:validation:Optional
	ContactPointRef *v1.Reference `json:"contactPointRef,omitempty" tf:"-"`

	// Selector for a ContactPoint in alerting to populate contactPoint.
	// +kubebuilder:validation:Optional
	ContactPointSelector *v1.Selector `json:"contactPointSelector,omitempty" tf:"-"`

	// A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
	// +kubebuilder:validation:Required
	GroupBy []*string `json:"groupBy" tf:"group_by,omitempty"`

	// Minimum time interval between two notifications for the same group. Default is 5 minutes.
	// +kubebuilder:validation:Optional
	GroupInterval *string `json:"groupInterval,omitempty" tf:"group_interval,omitempty"`

	// Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
	// +kubebuilder:validation:Optional
	GroupWait *string `json:"groupWait,omitempty" tf:"group_wait,omitempty"`

	// Routing rules for specific label sets.
	// +kubebuilder:validation:Optional
	Policy []PolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
	// +kubebuilder:validation:Optional
	RepeatInterval *string `json:"repeatInterval,omitempty" tf:"repeat_interval,omitempty"`
}

type PolicyMatcherObservation struct {
}

type PolicyMatcherParameters struct {

	// The name of the label to match against.
	// +kubebuilder:validation:Required
	Label *string `json:"label" tf:"label,omitempty"`

	// The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
	// +kubebuilder:validation:Required
	Match *string `json:"match" tf:"match,omitempty"`

	// The label value to match against.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type PolicyObservation struct {
}

type PolicyParameters struct {

	// The contact point to route notifications that match this rule to.
	// +kubebuilder:validation:Required
	ContactPoint *string `json:"contactPoint" tf:"contact_point,omitempty"`

	// Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
	// +kubebuilder:validation:Optional
	Continue *bool `json:"continue,omitempty" tf:"continue,omitempty"`

	// A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
	// +kubebuilder:validation:Required
	GroupBy []*string `json:"groupBy" tf:"group_by,omitempty"`

	// Minimum time interval between two notifications for the same group. Default is 5 minutes.
	// +kubebuilder:validation:Optional
	GroupInterval *string `json:"groupInterval,omitempty" tf:"group_interval,omitempty"`

	// Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
	// +kubebuilder:validation:Optional
	GroupWait *string `json:"groupWait,omitempty" tf:"group_wait,omitempty"`

	// Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
	// +kubebuilder:validation:Optional
	Matcher []MatcherParameters `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// A list of mute timing names to apply to alerts that match this policy.
	// +kubebuilder:validation:Optional
	MuteTimings []*string `json:"muteTimings,omitempty" tf:"mute_timings,omitempty"`

	// Routing rules for specific label sets.
	// +kubebuilder:validation:Optional
	Policy []PolicyPolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
	// +kubebuilder:validation:Optional
	RepeatInterval *string `json:"repeatInterval,omitempty" tf:"repeat_interval,omitempty"`
}

type PolicyPolicyMatcherObservation struct {
}

type PolicyPolicyMatcherParameters struct {

	// The name of the label to match against.
	// +kubebuilder:validation:Required
	Label *string `json:"label" tf:"label,omitempty"`

	// The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
	// +kubebuilder:validation:Required
	Match *string `json:"match" tf:"match,omitempty"`

	// The label value to match against.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type PolicyPolicyObservation struct {
}

type PolicyPolicyParameters struct {

	// The contact point to route notifications that match this rule to.
	// +kubebuilder:validation:Required
	ContactPoint *string `json:"contactPoint" tf:"contact_point,omitempty"`

	// Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
	// +kubebuilder:validation:Optional
	Continue *bool `json:"continue,omitempty" tf:"continue,omitempty"`

	// A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
	// +kubebuilder:validation:Required
	GroupBy []*string `json:"groupBy" tf:"group_by,omitempty"`

	// Minimum time interval between two notifications for the same group. Default is 5 minutes.
	// +kubebuilder:validation:Optional
	GroupInterval *string `json:"groupInterval,omitempty" tf:"group_interval,omitempty"`

	// Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
	// +kubebuilder:validation:Optional
	GroupWait *string `json:"groupWait,omitempty" tf:"group_wait,omitempty"`

	// Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
	// +kubebuilder:validation:Optional
	Matcher []PolicyMatcherParameters `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// A list of mute timing names to apply to alerts that match this policy.
	// +kubebuilder:validation:Optional
	MuteTimings []*string `json:"muteTimings,omitempty" tf:"mute_timings,omitempty"`

	// Routing rules for specific label sets.
	// +kubebuilder:validation:Optional
	Policy []PolicyPolicyPolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
	// +kubebuilder:validation:Optional
	RepeatInterval *string `json:"repeatInterval,omitempty" tf:"repeat_interval,omitempty"`
}

type PolicyPolicyPolicyMatcherObservation struct {
}

type PolicyPolicyPolicyMatcherParameters struct {

	// The name of the label to match against.
	// +kubebuilder:validation:Required
	Label *string `json:"label" tf:"label,omitempty"`

	// The operator to apply when matching values of the given label. Allowed operators are `=` for equality, `!=` for negated equality, `=~` for regex equality, and `!~` for negated regex equality.
	// +kubebuilder:validation:Required
	Match *string `json:"match" tf:"match,omitempty"`

	// The label value to match against.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type PolicyPolicyPolicyObservation struct {
}

type PolicyPolicyPolicyParameters struct {

	// The contact point to route notifications that match this rule to.
	// +kubebuilder:validation:Required
	ContactPoint *string `json:"contactPoint" tf:"contact_point,omitempty"`

	// Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
	// +kubebuilder:validation:Optional
	Continue *bool `json:"continue,omitempty" tf:"continue,omitempty"`

	// A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
	// +kubebuilder:validation:Required
	GroupBy []*string `json:"groupBy" tf:"group_by,omitempty"`

	// Minimum time interval between two notifications for the same group. Default is 5 minutes.
	// +kubebuilder:validation:Optional
	GroupInterval *string `json:"groupInterval,omitempty" tf:"group_interval,omitempty"`

	// Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
	// +kubebuilder:validation:Optional
	GroupWait *string `json:"groupWait,omitempty" tf:"group_wait,omitempty"`

	// Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
	// +kubebuilder:validation:Optional
	Matcher []PolicyPolicyMatcherParameters `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// A list of mute timing names to apply to alerts that match this policy.
	// +kubebuilder:validation:Optional
	MuteTimings []*string `json:"muteTimings,omitempty" tf:"mute_timings,omitempty"`

	// Routing rules for specific label sets.
	// +kubebuilder:validation:Optional
	Policy []PolicyPolicyPolicyPolicyParameters `json:"policy,omitempty" tf:"policy,omitempty"`

	// Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
	// +kubebuilder:validation:Optional
	RepeatInterval *string `json:"repeatInterval,omitempty" tf:"repeat_interval,omitempty"`
}

type PolicyPolicyPolicyPolicyObservation struct {
}

type PolicyPolicyPolicyPolicyParameters struct {

	// The contact point to route notifications that match this rule to.
	// +kubebuilder:validation:Required
	ContactPoint *string `json:"contactPoint" tf:"contact_point,omitempty"`

	// Whether to continue matching subsequent rules if an alert matches the current rule. Otherwise, the rule will be 'consumed' by the first policy to match it.
	// +kubebuilder:validation:Optional
	Continue *bool `json:"continue,omitempty" tf:"continue,omitempty"`

	// A list of alert labels to group alerts into notifications by. Use the special label `...` to group alerts by all labels, effectively disabling grouping.
	// +kubebuilder:validation:Required
	GroupBy []*string `json:"groupBy" tf:"group_by,omitempty"`

	// Minimum time interval between two notifications for the same group. Default is 5 minutes.
	// +kubebuilder:validation:Optional
	GroupInterval *string `json:"groupInterval,omitempty" tf:"group_interval,omitempty"`

	// Time to wait to buffer alerts of the same group before sending a notification. Default is 30 seconds.
	// +kubebuilder:validation:Optional
	GroupWait *string `json:"groupWait,omitempty" tf:"group_wait,omitempty"`

	// Describes which labels this rule should match. When multiple matchers are supplied, an alert must match ALL matchers to be accepted by this policy. When no matchers are supplied, the rule will match all alert instances.
	// +kubebuilder:validation:Optional
	Matcher []PolicyPolicyPolicyMatcherParameters `json:"matcher,omitempty" tf:"matcher,omitempty"`

	// A list of mute timing names to apply to alerts that match this policy.
	// +kubebuilder:validation:Optional
	MuteTimings []*string `json:"muteTimings,omitempty" tf:"mute_timings,omitempty"`

	// Minimum time interval for re-sending a notification if an alert is still firing. Default is 4 hours.
	// +kubebuilder:validation:Optional
	RepeatInterval *string `json:"repeatInterval,omitempty" tf:"repeat_interval,omitempty"`
}

// NotificationPolicySpec defines the desired state of NotificationPolicy
type NotificationPolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     NotificationPolicyParameters `json:"forProvider"`
}

// NotificationPolicyStatus defines the observed state of NotificationPolicy.
type NotificationPolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        NotificationPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// NotificationPolicy is the Schema for the NotificationPolicys API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,grafana}
type NotificationPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NotificationPolicySpec   `json:"spec"`
	Status            NotificationPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NotificationPolicyList contains a list of NotificationPolicys
type NotificationPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NotificationPolicy `json:"items"`
}

// Repository type metadata.
var (
	NotificationPolicy_Kind             = "NotificationPolicy"
	NotificationPolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: NotificationPolicy_Kind}.String()
	NotificationPolicy_KindAPIVersion   = NotificationPolicy_Kind + "." + CRDGroupVersion.String()
	NotificationPolicy_GroupVersionKind = CRDGroupVersion.WithKind(NotificationPolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&NotificationPolicy{}, &NotificationPolicyList{})
}
