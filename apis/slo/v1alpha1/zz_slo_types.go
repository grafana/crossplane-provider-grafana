/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AlertingInitParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations will be attached to all alerts generated by any of these rules.
	Annotation []AnnotationInitParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)
	// Alerting Rules generated for Fast Burn alerts
	Fastburn []FastburnInitParameters `json:"fastburn,omitempty" tf:"fastburn,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels will be attached to all alerts generated by any of these rules.
	Label []AlertingLabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)
	// Alerting Rules generated for Slow Burn alerts
	Slowburn []SlowburnInitParameters `json:"slowburn,omitempty" tf:"slowburn,omitempty"`
}

type AlertingLabelInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AlertingLabelObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AlertingLabelParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type AlertingObservation struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations will be attached to all alerts generated by any of these rules.
	Annotation []AnnotationObservation `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)
	// Alerting Rules generated for Fast Burn alerts
	Fastburn []FastburnObservation `json:"fastburn,omitempty" tf:"fastburn,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels will be attached to all alerts generated by any of these rules.
	Label []AlertingLabelObservation `json:"label,omitempty" tf:"label,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)
	// Alerting Rules generated for Slow Burn alerts
	Slowburn []SlowburnObservation `json:"slowburn,omitempty" tf:"slowburn,omitempty"`
}

type AlertingParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations will be attached to all alerts generated by any of these rules.
	// +kubebuilder:validation:Optional
	Annotation []AnnotationParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)
	// Alerting Rules generated for Fast Burn alerts
	// +kubebuilder:validation:Optional
	Fastburn []FastburnParameters `json:"fastburn,omitempty" tf:"fastburn,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels will be attached to all alerts generated by any of these rules.
	// +kubebuilder:validation:Optional
	Label []AlertingLabelParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)
	// Alerting Rules generated for Slow Burn alerts
	// +kubebuilder:validation:Optional
	Slowburn []SlowburnParameters `json:"slowburn,omitempty" tf:"slowburn,omitempty"`
}

type AnnotationInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AnnotationObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AnnotationParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type DestinationDatasourceInitParameters struct {

	// Reference to a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Ref *v1.Reference `json:"ref,omitempty" tf:"-"`

	// Selector for a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Selector *v1.Selector `json:"selector,omitempty" tf:"-"`

	// (String) UID for the Mimir Datasource
	// UID for the Mimir Datasource
	// +crossplane:generate:reference:type=github.com/grafana/crossplane-provider-grafana/apis/oss/v1alpha1.DataSource
	// +crossplane:generate:reference:extractor=github.com/grafana/crossplane-provider-grafana/config/grafana.OptionalFieldExtractor("uid")
	// +crossplane:generate:reference:refFieldName=Ref
	// +crossplane:generate:reference:selectorFieldName=Selector
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type DestinationDatasourceObservation struct {

	// (String) UID for the Mimir Datasource
	// UID for the Mimir Datasource
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type DestinationDatasourceParameters struct {

	// Reference to a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Ref *v1.Reference `json:"ref,omitempty" tf:"-"`

	// Selector for a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Selector *v1.Selector `json:"selector,omitempty" tf:"-"`

	// (String) UID for the Mimir Datasource
	// UID for the Mimir Datasource
	// +crossplane:generate:reference:type=github.com/grafana/crossplane-provider-grafana/apis/oss/v1alpha1.DataSource
	// +crossplane:generate:reference:extractor=github.com/grafana/crossplane-provider-grafana/config/grafana.OptionalFieldExtractor("uid")
	// +crossplane:generate:reference:refFieldName=Ref
	// +crossplane:generate:reference:selectorFieldName=Selector
	// +kubebuilder:validation:Optional
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type FastburnAnnotationInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type FastburnAnnotationObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type FastburnAnnotationParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type FastburnInitParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Fast Burn alerts.
	Annotation []FastburnAnnotationInitParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Fast Burn alerts.
	Label []LabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`
}

type FastburnObservation struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Fast Burn alerts.
	Annotation []FastburnAnnotationObservation `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Fast Burn alerts.
	Label []LabelObservation `json:"label,omitempty" tf:"label,omitempty"`
}

type FastburnParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Fast Burn alerts.
	// +kubebuilder:validation:Optional
	Annotation []FastburnAnnotationParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Fast Burn alerts.
	// +kubebuilder:validation:Optional
	Label []LabelParameters `json:"label,omitempty" tf:"label,omitempty"`
}

type FreeformInitParameters struct {

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Freeform Query Field
	Query *string `json:"query,omitempty" tf:"query,omitempty"`
}

type FreeformObservation struct {

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Freeform Query Field
	Query *string `json:"query,omitempty" tf:"query,omitempty"`
}

type FreeformParameters struct {

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Freeform Query Field
	// +kubebuilder:validation:Optional
	Query *string `json:"query" tf:"query,omitempty"`
}

type LabelInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ObjectivesInitParameters struct {

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`

	// parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	Window *string `json:"window,omitempty" tf:"window,omitempty"`
}

type ObjectivesObservation struct {

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`

	// parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	Window *string `json:"window,omitempty" tf:"window,omitempty"`
}

type ObjectivesParameters struct {

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *float64 `json:"value" tf:"value,omitempty"`

	// parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// +kubebuilder:validation:Optional
	Window *string `json:"window" tf:"window,omitempty"`
}

type QueryInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	Freeform []FreeformInitParameters `json:"freeform,omitempty" tf:"freeform,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Ratio []RatioInitParameters `json:"ratio,omitempty" tf:"ratio,omitempty"`

	// (String) Query type must be one of: "freeform", "query", "ratio", or "threshold"
	// Query type must be one of: "freeform", "query", "ratio", or "threshold"
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type QueryObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	Freeform []FreeformObservation `json:"freeform,omitempty" tf:"freeform,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Ratio []RatioObservation `json:"ratio,omitempty" tf:"ratio,omitempty"`

	// (String) Query type must be one of: "freeform", "query", "ratio", or "threshold"
	// Query type must be one of: "freeform", "query", "ratio", or "threshold"
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type QueryParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Freeform []FreeformParameters `json:"freeform,omitempty" tf:"freeform,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Ratio []RatioParameters `json:"ratio,omitempty" tf:"ratio,omitempty"`

	// (String) Query type must be one of: "freeform", "query", "ratio", or "threshold"
	// Query type must be one of: "freeform", "query", "ratio", or "threshold"
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type RatioInitParameters struct {

	// label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	GroupByLabels []*string `json:"groupByLabels,omitempty" tf:"group_by_labels,omitempty"`

	// (String) Counter metric for success events (numerator)
	// Counter metric for success events (numerator)
	SuccessMetric *string `json:"successMetric,omitempty" tf:"success_metric,omitempty"`

	// (String) Metric for total events (denominator)
	// Metric for total events (denominator)
	TotalMetric *string `json:"totalMetric,omitempty" tf:"total_metric,omitempty"`
}

type RatioObservation struct {

	// label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	GroupByLabels []*string `json:"groupByLabels,omitempty" tf:"group_by_labels,omitempty"`

	// (String) Counter metric for success events (numerator)
	// Counter metric for success events (numerator)
	SuccessMetric *string `json:"successMetric,omitempty" tf:"success_metric,omitempty"`

	// (String) Metric for total events (denominator)
	// Metric for total events (denominator)
	TotalMetric *string `json:"totalMetric,omitempty" tf:"total_metric,omitempty"`
}

type RatioParameters struct {

	// label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// +kubebuilder:validation:Optional
	GroupByLabels []*string `json:"groupByLabels,omitempty" tf:"group_by_labels,omitempty"`

	// (String) Counter metric for success events (numerator)
	// Counter metric for success events (numerator)
	// +kubebuilder:validation:Optional
	SuccessMetric *string `json:"successMetric" tf:"success_metric,omitempty"`

	// (String) Metric for total events (denominator)
	// Metric for total events (denominator)
	// +kubebuilder:validation:Optional
	TotalMetric *string `json:"totalMetric" tf:"total_metric,omitempty"`
}

type SLOInitParameters struct {

	// term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)
	// Configures the alerting rules that will be generated for each
	// time window associated with the SLO. Grafana SLOs can generate
	// alerts when the short-term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating.
	Alerting []AlertingInitParameters `json:"alerting,omitempty" tf:"alerting,omitempty"`

	// text field that can provide more context to an SLO.
	// Description is a free-text field that can provide more context to an SLO.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)
	// Destination Datasource sets the datasource defined for an SLO
	DestinationDatasource []DestinationDatasourceInitParameters `json:"destinationDatasource,omitempty" tf:"destination_datasource,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	Label []SLOLabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (String) Name should be a short description of your indicator. Consider names like "API Availability"
	// Name should be a short description of your indicator. Consider names like "API Availability"
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)
	// Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
	Objectives []ObjectivesInitParameters `json:"objectives,omitempty" tf:"objectives,omitempty"`

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
	Query []QueryInitParameters `json:"query,omitempty" tf:"query,omitempty"`
}

type SLOLabelInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SLOLabelObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SLOLabelParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type SLOObservation struct {

	// term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)
	// Configures the alerting rules that will be generated for each
	// time window associated with the SLO. Grafana SLOs can generate
	// alerts when the short-term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating.
	Alerting []AlertingObservation `json:"alerting,omitempty" tf:"alerting,omitempty"`

	// text field that can provide more context to an SLO.
	// Description is a free-text field that can provide more context to an SLO.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)
	// Destination Datasource sets the datasource defined for an SLO
	DestinationDatasource []DestinationDatasourceObservation `json:"destinationDatasource,omitempty" tf:"destination_datasource,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	Label []SLOLabelObservation `json:"label,omitempty" tf:"label,omitempty"`

	// (String) Name should be a short description of your indicator. Consider names like "API Availability"
	// Name should be a short description of your indicator. Consider names like "API Availability"
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)
	// Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
	Objectives []ObjectivesObservation `json:"objectives,omitempty" tf:"objectives,omitempty"`

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
	Query []QueryObservation `json:"query,omitempty" tf:"query,omitempty"`
}

type SLOParameters struct {

	// term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)
	// Configures the alerting rules that will be generated for each
	// time window associated with the SLO. Grafana SLOs can generate
	// alerts when the short-term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating.
	// +kubebuilder:validation:Optional
	Alerting []AlertingParameters `json:"alerting,omitempty" tf:"alerting,omitempty"`

	// text field that can provide more context to an SLO.
	// Description is a free-text field that can provide more context to an SLO.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)
	// Destination Datasource sets the datasource defined for an SLO
	// +kubebuilder:validation:Optional
	DestinationDatasource []DestinationDatasourceParameters `json:"destinationDatasource,omitempty" tf:"destination_datasource,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// +kubebuilder:validation:Optional
	Label []SLOLabelParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (String) Name should be a short description of your indicator. Consider names like "API Availability"
	// Name should be a short description of your indicator. Consider names like "API Availability"
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)
	// Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
	// +kubebuilder:validation:Optional
	Objectives []ObjectivesParameters `json:"objectives,omitempty" tf:"objectives,omitempty"`

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
	// +kubebuilder:validation:Optional
	Query []QueryParameters `json:"query,omitempty" tf:"query,omitempty"`
}

type SlowburnAnnotationInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnAnnotationObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnAnnotationParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type SlowburnInitParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Slow Burn alerts.
	Annotation []SlowburnAnnotationInitParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Slow Burn alerts.
	Label []SlowburnLabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`
}

type SlowburnLabelInitParameters struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnLabelObservation struct {

	// (String)
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnLabelParameters struct {

	// (String)
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type SlowburnObservation struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Slow Burn alerts.
	Annotation []SlowburnAnnotationObservation `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Slow Burn alerts.
	Label []SlowburnLabelObservation `json:"label,omitempty" tf:"label,omitempty"`
}

type SlowburnParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Slow Burn alerts.
	// +kubebuilder:validation:Optional
	Annotation []SlowburnAnnotationParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Slow Burn alerts.
	// +kubebuilder:validation:Optional
	Label []SlowburnLabelParameters `json:"label,omitempty" tf:"label,omitempty"`
}

// SLOSpec defines the desired state of SLO
type SLOSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SLOParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SLOInitParameters `json:"initProvider,omitempty"`
}

// SLOStatus defines the observed state of SLO.
type SLOStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SLOObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SLO is the Schema for the SLOs API. Resource manages Grafana SLOs. Official documentation https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/API documentation https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/api/Additional Information On Alerting Rule Annotations and Labels https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/#templating/
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,grafana}
type SLO struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.description) || (has(self.initProvider) && has(self.initProvider.description))",message="spec.forProvider.description is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.objectives) || (has(self.initProvider) && has(self.initProvider.objectives))",message="spec.forProvider.objectives is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.query) || (has(self.initProvider) && has(self.initProvider.query))",message="spec.forProvider.query is a required parameter"
	Spec   SLOSpec   `json:"spec"`
	Status SLOStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SLOList contains a list of SLOs
type SLOList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SLO `json:"items"`
}

// Repository type metadata.
var (
	SLO_Kind             = "SLO"
	SLO_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SLO_Kind}.String()
	SLO_KindAPIVersion   = SLO_Kind + "." + CRDGroupVersion.String()
	SLO_GroupVersionKind = CRDGroupVersion.WithKind(SLO_Kind)
)

func init() {
	SchemeBuilder.Register(&SLO{}, &SLOList{})
}
