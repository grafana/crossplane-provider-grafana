/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdvancedOptionsInitParameters struct {

	// (Number) Minimum number of failed events to trigger an alert
	// Minimum number of failed events to trigger an alert
	MinFailures *float64 `json:"minFailures,omitempty" tf:"min_failures,omitempty"`
}

type AdvancedOptionsObservation struct {

	// (Number) Minimum number of failed events to trigger an alert
	// Minimum number of failed events to trigger an alert
	MinFailures *float64 `json:"minFailures,omitempty" tf:"min_failures,omitempty"`
}

type AdvancedOptionsParameters struct {

	// (Number) Minimum number of failed events to trigger an alert
	// Minimum number of failed events to trigger an alert
	// +kubebuilder:validation:Optional
	MinFailures *float64 `json:"minFailures,omitempty" tf:"min_failures,omitempty"`
}

type AlertingInitParameters struct {

	// (Block List, Max: 1) Advanced Options for Alert Rules (see below for nested schema)
	// Advanced Options for Alert Rules
	AdvancedOptions []AdvancedOptionsInitParameters `json:"advancedOptions,omitempty" tf:"advanced_options,omitempty"`

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations will be attached to all alerts generated by any of these rules.
	Annotation []AnnotationInitParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)
	// Alerting Rules generated for Fast Burn alerts
	Fastburn []FastburnInitParameters `json:"fastburn,omitempty" tf:"fastburn,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels will be attached to all alerts generated by any of these rules.
	Label []AlertingLabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)
	// Alerting Rules generated for Slow Burn alerts
	Slowburn []SlowburnInitParameters `json:"slowburn,omitempty" tf:"slowburn,omitempty"`
}

type AlertingLabelInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AlertingLabelObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AlertingLabelParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type AlertingObservation struct {

	// (Block List, Max: 1) Advanced Options for Alert Rules (see below for nested schema)
	// Advanced Options for Alert Rules
	AdvancedOptions []AdvancedOptionsObservation `json:"advancedOptions,omitempty" tf:"advanced_options,omitempty"`

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations will be attached to all alerts generated by any of these rules.
	Annotation []AnnotationObservation `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)
	// Alerting Rules generated for Fast Burn alerts
	Fastburn []FastburnObservation `json:"fastburn,omitempty" tf:"fastburn,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels will be attached to all alerts generated by any of these rules.
	Label []AlertingLabelObservation `json:"label,omitempty" tf:"label,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)
	// Alerting Rules generated for Slow Burn alerts
	Slowburn []SlowburnObservation `json:"slowburn,omitempty" tf:"slowburn,omitempty"`
}

type AlertingParameters struct {

	// (Block List, Max: 1) Advanced Options for Alert Rules (see below for nested schema)
	// Advanced Options for Alert Rules
	// +kubebuilder:validation:Optional
	AdvancedOptions []AdvancedOptionsParameters `json:"advancedOptions,omitempty" tf:"advanced_options,omitempty"`

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations will be attached to all alerts generated by any of these rules.
	// +kubebuilder:validation:Optional
	Annotation []AnnotationParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Fast Burn alerts (see below for nested schema)
	// Alerting Rules generated for Fast Burn alerts
	// +kubebuilder:validation:Optional
	Fastburn []FastburnParameters `json:"fastburn,omitempty" tf:"fastburn,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels will be attached to all alerts generated by any of these rules.
	// +kubebuilder:validation:Optional
	Label []AlertingLabelParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (Block List, Max: 1) Alerting Rules generated for Slow Burn alerts (see below for nested schema)
	// Alerting Rules generated for Slow Burn alerts
	// +kubebuilder:validation:Optional
	Slowburn []SlowburnParameters `json:"slowburn,omitempty" tf:"slowburn,omitempty"`
}

type AnnotationInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AnnotationObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type AnnotationParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type DestinationDatasourceInitParameters struct {

	// Reference to a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Ref *v1.Reference `json:"ref,omitempty" tf:"-"`

	// Selector for a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Selector *v1.Selector `json:"selector,omitempty" tf:"-"`

	// (String) UID for the Datasource
	// UID for the Datasource
	// +crossplane:generate:reference:type=github.com/grafana/crossplane-provider-grafana/apis/oss/v1alpha1.DataSource
	// +crossplane:generate:reference:extractor=github.com/grafana/crossplane-provider-grafana/config/grafana.OptionalFieldExtractor("uid")
	// +crossplane:generate:reference:refFieldName=Ref
	// +crossplane:generate:reference:selectorFieldName=Selector
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type DestinationDatasourceObservation struct {

	// (String) UID for the Datasource
	// UID for the Datasource
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type DestinationDatasourceParameters struct {

	// Reference to a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Ref *v1.Reference `json:"ref,omitempty" tf:"-"`

	// Selector for a DataSource in oss to populate uid.
	// +kubebuilder:validation:Optional
	Selector *v1.Selector `json:"selector,omitempty" tf:"-"`

	// (String) UID for the Datasource
	// UID for the Datasource
	// +crossplane:generate:reference:type=github.com/grafana/crossplane-provider-grafana/apis/oss/v1alpha1.DataSource
	// +crossplane:generate:reference:extractor=github.com/grafana/crossplane-provider-grafana/config/grafana.OptionalFieldExtractor("uid")
	// +crossplane:generate:reference:refFieldName=Ref
	// +crossplane:generate:reference:selectorFieldName=Selector
	// +kubebuilder:validation:Optional
	UID *string `json:"uid,omitempty" tf:"uid,omitempty"`
}

type FastburnAnnotationInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type FastburnAnnotationObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type FastburnAnnotationParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type FastburnInitParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Fast Burn alerts.
	Annotation []FastburnAnnotationInitParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Fast Burn alerts.
	Label []LabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`
}

type FastburnObservation struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Fast Burn alerts.
	Annotation []FastburnAnnotationObservation `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Fast Burn alerts.
	Label []LabelObservation `json:"label,omitempty" tf:"label,omitempty"`
}

type FastburnParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Fast Burn alerts.
	// +kubebuilder:validation:Optional
	Annotation []FastburnAnnotationParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Fast Burn alerts.
	// +kubebuilder:validation:Optional
	Label []LabelParameters `json:"label,omitempty" tf:"label,omitempty"`
}

type FreeformInitParameters struct {

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Freeform Query Field - valid promQl
	Query *string `json:"query,omitempty" tf:"query,omitempty"`
}

type FreeformObservation struct {

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Freeform Query Field - valid promQl
	Query *string `json:"query,omitempty" tf:"query,omitempty"`
}

type FreeformParameters struct {

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Freeform Query Field - valid promQl
	// +kubebuilder:validation:Optional
	Query *string `json:"query" tf:"query,omitempty"`
}

type GrafanaQueriesInitParameters struct {

	// (Block List, Max: 1) Array for holding a set of grafana queries (see below for nested schema)
	// Query Object - Array of Grafana Query JSON objects
	GrafanaQueries *string `json:"grafanaQueries,omitempty" tf:"grafana_queries,omitempty"`
}

type GrafanaQueriesObservation struct {

	// (Block List, Max: 1) Array for holding a set of grafana queries (see below for nested schema)
	// Query Object - Array of Grafana Query JSON objects
	GrafanaQueries *string `json:"grafanaQueries,omitempty" tf:"grafana_queries,omitempty"`
}

type GrafanaQueriesParameters struct {

	// (Block List, Max: 1) Array for holding a set of grafana queries (see below for nested schema)
	// Query Object - Array of Grafana Query JSON objects
	// +kubebuilder:validation:Optional
	GrafanaQueries *string `json:"grafanaQueries" tf:"grafana_queries,omitempty"`
}

type LabelInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type ObjectivesInitParameters struct {

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`

	// parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	Window *string `json:"window,omitempty" tf:"window,omitempty"`
}

type ObjectivesObservation struct {

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	Value *float64 `json:"value,omitempty" tf:"value,omitempty"`

	// parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	Window *string `json:"window,omitempty" tf:"window,omitempty"`
}

type ObjectivesParameters struct {

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// +kubebuilder:validation:Optional
	Value *float64 `json:"value" tf:"value,omitempty"`

	// parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// A Prometheus-parsable time duration string like 24h, 60m. This is the time window the objective is measured over.
	// +kubebuilder:validation:Optional
	Window *string `json:"window" tf:"window,omitempty"`
}

type QueryInitParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	Freeform []FreeformInitParameters `json:"freeform,omitempty" tf:"freeform,omitempty"`

	// (Block List, Max: 1) Array for holding a set of grafana queries (see below for nested schema)
	// Array for holding a set of grafana queries
	GrafanaQueries []GrafanaQueriesInitParameters `json:"grafanaQueries,omitempty" tf:"grafana_queries,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Ratio []RatioInitParameters `json:"ratio,omitempty" tf:"ratio,omitempty"`

	// (String) Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
	// Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type QueryObservation struct {

	// (Block List, Max: 1) (see below for nested schema)
	Freeform []FreeformObservation `json:"freeform,omitempty" tf:"freeform,omitempty"`

	// (Block List, Max: 1) Array for holding a set of grafana queries (see below for nested schema)
	// Array for holding a set of grafana queries
	GrafanaQueries []GrafanaQueriesObservation `json:"grafanaQueries,omitempty" tf:"grafana_queries,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	Ratio []RatioObservation `json:"ratio,omitempty" tf:"ratio,omitempty"`

	// (String) Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
	// Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type QueryParameters struct {

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Freeform []FreeformParameters `json:"freeform,omitempty" tf:"freeform,omitempty"`

	// (Block List, Max: 1) Array for holding a set of grafana queries (see below for nested schema)
	// Array for holding a set of grafana queries
	// +kubebuilder:validation:Optional
	GrafanaQueries []GrafanaQueriesParameters `json:"grafanaQueries,omitempty" tf:"grafana_queries,omitempty"`

	// (Block List, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	Ratio []RatioParameters `json:"ratio,omitempty" tf:"ratio,omitempty"`

	// (String) Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
	// Query type must be one of: "freeform", "query", "ratio", "grafana_queries" or "threshold"
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type RatioInitParameters struct {

	// label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	GroupByLabels []*string `json:"groupByLabels,omitempty" tf:"group_by_labels,omitempty"`

	// (String) Counter metric for success events (numerator)
	// Counter metric for success events (numerator)
	SuccessMetric *string `json:"successMetric,omitempty" tf:"success_metric,omitempty"`

	// (String) Metric for total events (denominator)
	// Metric for total events (denominator)
	TotalMetric *string `json:"totalMetric,omitempty" tf:"total_metric,omitempty"`
}

type RatioObservation struct {

	// label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	GroupByLabels []*string `json:"groupByLabels,omitempty" tf:"group_by_labels,omitempty"`

	// (String) Counter metric for success events (numerator)
	// Counter metric for success events (numerator)
	SuccessMetric *string `json:"successMetric,omitempty" tf:"success_metric,omitempty"`

	// (String) Metric for total events (denominator)
	// Metric for total events (denominator)
	TotalMetric *string `json:"totalMetric,omitempty" tf:"total_metric,omitempty"`
}

type RatioParameters struct {

	// label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// Defines Group By Labels used for per-label alerting. These appear as variables on SLO dashboards to enable filtering and aggregation. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// +kubebuilder:validation:Optional
	GroupByLabels []*string `json:"groupByLabels,omitempty" tf:"group_by_labels,omitempty"`

	// (String) Counter metric for success events (numerator)
	// Counter metric for success events (numerator)
	// +kubebuilder:validation:Optional
	SuccessMetric *string `json:"successMetric" tf:"success_metric,omitempty"`

	// (String) Metric for total events (denominator)
	// Metric for total events (denominator)
	// +kubebuilder:validation:Optional
	TotalMetric *string `json:"totalMetric" tf:"total_metric,omitempty"`
}

type SLOInitParameters struct {

	// term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)
	// Configures the alerting rules that will be generated for each
	// time window associated with the SLO. Grafana SLOs can generate
	// alerts when the short-term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating.
	Alerting []AlertingInitParameters `json:"alerting,omitempty" tf:"alerting,omitempty"`

	// text field that can provide more context to an SLO.
	// Description is a free-text field that can provide more context to an SLO.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Min: 1, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)
	// Destination Datasource sets the datasource defined for an SLO
	DestinationDatasource []DestinationDatasourceInitParameters `json:"destinationDatasource,omitempty" tf:"destination_datasource,omitempty"`

	// (String) UID for the SLO folder
	// UID for the SLO folder
	FolderUID *string `json:"folderUid,omitempty" tf:"folder_uid,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	Label []SLOLabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (String) Name should be a short description of your indicator. Consider names like "API Availability"
	// Name should be a short description of your indicator. Consider names like "API Availability"
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)
	// Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
	Objectives []ObjectivesInitParameters `json:"objectives,omitempty" tf:"objectives,omitempty"`

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
	Query []QueryInitParameters `json:"query,omitempty" tf:"query,omitempty"`

	// (String) The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
	// The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
	SearchExpression *string `json:"searchExpression,omitempty" tf:"search_expression,omitempty"`

	// (String) UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.
	// UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type SLOLabelInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SLOLabelObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SLOLabelParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type SLOObservation struct {

	// term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)
	// Configures the alerting rules that will be generated for each
	// time window associated with the SLO. Grafana SLOs can generate
	// alerts when the short-term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating.
	Alerting []AlertingObservation `json:"alerting,omitempty" tf:"alerting,omitempty"`

	// text field that can provide more context to an SLO.
	// Description is a free-text field that can provide more context to an SLO.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Min: 1, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)
	// Destination Datasource sets the datasource defined for an SLO
	DestinationDatasource []DestinationDatasourceObservation `json:"destinationDatasource,omitempty" tf:"destination_datasource,omitempty"`

	// (String) UID for the SLO folder
	// UID for the SLO folder
	FolderUID *string `json:"folderUid,omitempty" tf:"folder_uid,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	Label []SLOLabelObservation `json:"label,omitempty" tf:"label,omitempty"`

	// (String) Name should be a short description of your indicator. Consider names like "API Availability"
	// Name should be a short description of your indicator. Consider names like "API Availability"
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)
	// Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
	Objectives []ObjectivesObservation `json:"objectives,omitempty" tf:"objectives,omitempty"`

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
	Query []QueryObservation `json:"query,omitempty" tf:"query,omitempty"`

	// (String) The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
	// The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
	SearchExpression *string `json:"searchExpression,omitempty" tf:"search_expression,omitempty"`

	// (String) UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.
	// UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type SLOParameters struct {

	// term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating. (see below for nested schema)
	// Configures the alerting rules that will be generated for each
	// time window associated with the SLO. Grafana SLOs can generate
	// alerts when the short-term error budget burn is very high, the
	// long-term error budget burn rate is high, or when the remaining
	// error budget is below a certain threshold. Annotations and Labels support templating.
	// +kubebuilder:validation:Optional
	Alerting []AlertingParameters `json:"alerting,omitempty" tf:"alerting,omitempty"`

	// text field that can provide more context to an SLO.
	// Description is a free-text field that can provide more context to an SLO.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (Block List, Min: 1, Max: 1) Destination Datasource sets the datasource defined for an SLO (see below for nested schema)
	// Destination Datasource sets the datasource defined for an SLO
	// +kubebuilder:validation:Optional
	DestinationDatasource []DestinationDatasourceParameters `json:"destinationDatasource,omitempty" tf:"destination_datasource,omitempty"`

	// (String) UID for the SLO folder
	// UID for the SLO folder
	// +kubebuilder:validation:Optional
	FolderUID *string `json:"folderUid,omitempty" tf:"folder_uid,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Additional labels that will be attached to all metrics generated from the query. These labels are useful for grouping SLOs in dashboard views that you create by hand. Labels must adhere to Prometheus label name schema - "^[a-zA-Z_][a-zA-Z0-9_]*$"
	// +kubebuilder:validation:Optional
	Label []SLOLabelParameters `json:"label,omitempty" tf:"label,omitempty"`

	// (String) Name should be a short description of your indicator. Consider names like "API Availability"
	// Name should be a short description of your indicator. Consider names like "API Availability"
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Block List, Min: 1) Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget. (see below for nested schema)
	// Over each rolling time window, the remaining error budget will be calculated, and separate alerts can be generated for each time window based on the SLO burn rate or remaining error budget.
	// +kubebuilder:validation:Optional
	Objectives []ObjectivesParameters `json:"objectives,omitempty" tf:"objectives,omitempty"`

	// (Block List, Min: 1) Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported. (see below for nested schema)
	// Query describes the indicator that will be measured against the objective. Freeform Query types are currently supported.
	// +kubebuilder:validation:Optional
	Query []QueryParameters `json:"query,omitempty" tf:"query,omitempty"`

	// (String) The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
	// The name of a search expression in Grafana Asserts. This is used in the SLO UI to open the Asserts RCA workbench and in alerts to link to the RCA workbench.
	// +kubebuilder:validation:Optional
	SearchExpression *string `json:"searchExpression,omitempty" tf:"search_expression,omitempty"`

	// (String) UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.
	// UUID for the SLO. Custom UUIDs can be set. If not provided, a random UUID will be generated by the API.
	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type SlowburnAnnotationInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnAnnotationObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnAnnotationParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type SlowburnInitParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Slow Burn alerts.
	Annotation []SlowburnAnnotationInitParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Slow Burn alerts.
	Label []SlowburnLabelInitParameters `json:"label,omitempty" tf:"label,omitempty"`
}

type SlowburnLabelInitParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnLabelObservation struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type SlowburnLabelParameters struct {

	// (String) Key for filtering and identification
	// Key for filtering and identification
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// (Number) Value between 0 and 1. If the value of the query is above the objective, the SLO is met.
	// Templatable value
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type SlowburnObservation struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Slow Burn alerts.
	Annotation []SlowburnAnnotationObservation `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Slow Burn alerts.
	Label []SlowburnLabelObservation `json:"label,omitempty" tf:"label,omitempty"`
}

type SlowburnParameters struct {

	// (Block List) Annotations will be attached to all alerts generated by any of these rules. (see below for nested schema)
	// Annotations to attach only to Slow Burn alerts.
	// +kubebuilder:validation:Optional
	Annotation []SlowburnAnnotationParameters `json:"annotation,omitempty" tf:"annotation,omitempty"`

	// "^[a-zA-Z_][a-zA-Z0-9_]*$" (see below for nested schema)
	// Labels to attach only to Slow Burn alerts.
	// +kubebuilder:validation:Optional
	Label []SlowburnLabelParameters `json:"label,omitempty" tf:"label,omitempty"`
}

// SLOSpec defines the desired state of SLO
type SLOSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SLOParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SLOInitParameters `json:"initProvider,omitempty"`
}

// SLOStatus defines the observed state of SLO.
type SLOStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SLOObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// SLO is the Schema for the SLOs API. Resource manages Grafana SLOs. Official documentation https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/API documentation https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/api/Additional Information On Alerting Rule Annotations and Labels https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/#templating/
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,grafana}
type SLO struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.description) || (has(self.initProvider) && has(self.initProvider.description))",message="spec.forProvider.description is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.destinationDatasource) || (has(self.initProvider) && has(self.initProvider.destinationDatasource))",message="spec.forProvider.destinationDatasource is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.objectives) || (has(self.initProvider) && has(self.initProvider.objectives))",message="spec.forProvider.objectives is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.query) || (has(self.initProvider) && has(self.initProvider.query))",message="spec.forProvider.query is a required parameter"
	Spec   SLOSpec   `json:"spec"`
	Status SLOStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SLOList contains a list of SLOs
type SLOList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SLO `json:"items"`
}

// Repository type metadata.
var (
	SLO_Kind             = "SLO"
	SLO_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SLO_Kind}.String()
	SLO_KindAPIVersion   = SLO_Kind + "." + CRDGroupVersion.String()
	SLO_GroupVersionKind = CRDGroupVersion.WithKind(SLO_Kind)
)

func init() {
	SchemeBuilder.Register(&SLO{}, &SLOList{})
}
